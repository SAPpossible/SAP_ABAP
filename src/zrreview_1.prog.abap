REPORT zrreview_1.

DATA : gv_char1 TYPE c.

gv_char1 = 'A'.

"CHAR1 에 A 저장."

DATA : BEGIN OF gs_data1,
      gv_char1 TYPE c,
      gv_char2 TYPE c,
      gv_char3 TYPE c,
      END OF gs_data1.

DATA : BEGIN OF GS_DATA2.
DATA : GV_CHAR1 TYPE C,
       GV_CHAR2 TYPE C,
       GV_CHAR3.
DATA : END OF GS_DATA2.

WRITE : / GV_CHAR1. "A 출력 "

GS_DATA1-GV_CHAR1 = 'A'.
GS_DATA1-GV_CHAR2 = 'B'.
GS_DATA1-GV_CHAR3 = 'C'.

WRITE : / GS_DATA1.

TYPES : BEGIN OF TY_DATA3.
TYPES : GV_CHAR1,
        GV_CHAR2,
        GV_CHAR3.
TYPES : END OF TY_DATA3.

" 타입만들기 중"

DATA : GS_DATA4 TYPE TY_DATA3. " 타입을참고"
DATA : GS_DATA5 LIKE GS_DATA4. " 타입을 참고한 테이블을 참고"

DATA : BEGIN OF GS_DATA6,
        CHAR1 TYPE C,
        CHAR2 TYPE C,   " C 타입 선언"
        CHAR3 TYPE C,
        END OF GS_DATA6.

DATA : BEGIN OF GS_DATA7,
        CHAR3,
        CHAR2,     " 선언안하면 C 1자리 "
        CHAR1,
        END OF GS_DATA7.

DATA  : BEGIN OF GS_DATA8,
        CHAR3,
        CHAR2,
        CHAR1,
        END OF GS_DATA8.

 GS_DATA7-CHAR1 = 'A'.
 GS_DATA7-CHAR2 = 'B'.
 GS_DATA7-CHAR3 = 'C'.

 MOVE GS_DATA7 TO GS_DATA8.

 WRITE : / GS_DATA7 ,/ GS_DATA8. "CBA , CBA 같은 결과로 출력 순서 바뀌지 X."

 CLEAR : GS_DATA8.

 MOVE-CORRESPONDING GS_DATA7 TO GS_DATA8.

CLEAR : GS_DATA8.

 WRITE : / GS_DATA7,/ GS_DATA8.

 IF GS_DATA7 = GS_DATA8.
   MESSAGE '구조체가 같다.' TYPE 'S'. "A,W,E,I" "A는 빨간느낌표 W는 노란느낌표
 ELSEIF GS_DATA7 <> GS_DATA8.
   MESSAGE '구조체가 다르다.' TYPE 'I' DISPLAY LIKE 'A'.

 ENDIF.

 TYPES : BEGIN OF TY_DATA9,
           CHAR1,
           CHAR2,
           CHAR3,
         END OF TY_DATA9.

DATA : BEGIN OF GS_Data10.
  INCLUDE TYPE TY_DATA9.
 DATA : CHAR4.              " 타입 참고"
 DATA : END OF GS_DATA10.

 DATA : BEGIN OF GS_DATA11,
        CHAR1,
        CHAR2,
        CHAR3,
      END OF GS_DATA11.

DATA : BEGIN OF GS_DATA12.
  INCLUDE STRUCTURE GS_DATA11. " 스트럭처 참고 "
DATA : CHAR4.
DATA : END OF GS_DATA12.


TYPES : BEGIN OF TY_DATA14,

        CHAR1(10),
        CHAR2(10),
        CHAR3(10),
      END OF TY_DATA14.

DATA : GS_DATA15 TYPE TY_DATA14.
DATA : GT_DATA15 TYPE TABLE OF TY_DATA14. "테이블은 참고할때 TABLE OF 붙어야된다."

GS_DATA15-CHAR1 = 'AAA'.
GS_DATA15-CHAR2 = 'BBB'.
GS_DATA15-CHAR3 = 'CCC'.

APPEND GS_DATA15 TO GT_DATA15. " 스트럭처에 있는 값을 테이블에 넣는다."

DATA : BEGIN OF GS_DATA16,
        CHAR1(10),
        CHAR2(10),
        CHAR3(10),
      END OF GS_DATA16.

DATA  : GS_DATA17 LIKE GS_DATA16.
DATA : GT_DATA17 LIKE TABLE OF GS_DATA16. "스트럭쳐는 LIKE 테이블은 LIKE TABLE OF"

GS_DATA17-CHAR1 = 'AAA'.
GS_DATA17-CHAR2 = 'BBB'.
GS_DATA17-CHAR3 = 'CCC'.

INSERT GS_DATA17 INTO TABLE GT_DATA17. "INSERT INTO 와 APPEND TO 차이는 ??"

LOOP AT GT_DATA17 INTO GS_DATA17. " LOOP AT에는 INTO "

  WRITE : / GS_DATA17.

ENDLOOP.

*CL_DEMO_OUTPUT=>DISPLAY( GT_DATA17 ). " 테이블을 표로 띄워준다."

DATA : BEGIN OF GS_DATA18,
        CHAR1(10),
        NUM TYPE I,
        END OF GS_DATA18.

DATA : GT_DATA18 LIKE TABLE OF GS_DATA18.

GS_DATA18-CHAR1 = 'AAA'.
GS_DATA18-NUM = 1.
COLLECT GS_DATA18 INTO GT_DATA18.

GS_DATA18-CHAR1 = 'BBB'.
GS_DATA18-NUM = 2.                      " 문자가 같은것끼리 더한다. COLLECT.
COLLECT GS_DATA18 INTO GT_DATA18.

GS_DATA18-CHAR1 = 'AAA'.
GS_DATA18-NUM = 3.
COLLECT GS_DATA18 INTO GT_DATA18.

*CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

LOOP AT GT_DATA18 INTO GS_DATA18.

  GS_DATA18-NUM = 888. " LOOP 문이여서 각 행마다 전부 적용된다."

  MODIFY GT_DATA18 FROM GS_DATA18. " GS로 부터 GT를 변경"
*  MODIFY GT_DATA18 FROM GS_DATA18 INDEX SY-TABIX.
ENDLOOP.

*CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

LOOP AT GT_DATA18 INTO GS_DATA18.

  IF GS_DATA18-CHAR1 = 'AAA'.
    GS_DATA18-NUM = 777.
    ENDIF.                            "CHAR1 이 AAA면 NUM값을 777로 변경."

 MODIFY GT_DATA18 FROM GS_DATA18.

ENDLOOP.

*CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

LOOP AT GT_DATA18 INTO GS_DATA18 WHERE CHAR1 = 'AAA'.
  GS_DATA18-NUM = 666.

  MODIFY GT_DATA18 FROM GS_DATA18.        " IF 문 대신 WHERE 사용가능"

ENDLOOP.

*CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

DELETE GT_DATA18 WHERE CHAR1 = 'AAA'.

DATA : BEGIN OF GS_DATA19,
        CHAR1(10),
        NUM TYPE I,
        END OF GS_DATA19.

DATA : GT_DATA19 LIKE TABLE OF GS_DATA19.

GS_DATA19-CHAR1 = 'AAA'.
GS_DATA19-NUM = 1.
APPEND GS_DATA19 TO GT_DATA19.

GS_DATA19-CHAR1 = 'BBB'.
GS_DATA19-NUM = 2.
APPEND GS_DATA19 TO GT_DATA19.

GS_DATA19-CHAR1 = 'AAA'.
GS_DATA19-NUM = 3.
APPEND GS_DATA19 TO GT_DATA19.

GS_DATA19-CHAR1 = 'BBB'.
GS_DATA19-NUM = 4.
APPEND GS_DATA19 TO GT_DATA19.

*SORT GT_DATA19. " 정렬"
*SORT GT_DATA19 ASCENDING. "정순"
SORT GT_DATA19 DESCENDING. " 역순"

*DELETE ADJACENT DUPLICATES FROM GT_DATA19.

*CL_DEMO_OUTPUT=>DISPLAY( GT_DATA19 ).


CLEAR : GT_DATA19.
*REFRESH GT_DATA19.
*FREE GT_DATA19.

GS_DATA19-CHAR1 = 'AAA'.
GS_DATA19-NUM = 1.
APPEND GS_DATA19 TO GT_DATA19.

GS_DATA19-CHAR1 = 'BBB'.
GS_DATA19-NUM = 2.
APPEND GS_DATA19 TO GT_DATA19.

GS_DATA19-CHAR1 = 'AAA'.
GS_DATA19-NUM = 3.
APPEND GS_DATA19 TO GT_DATA19.

GS_DATA19-CHAR1 = 'BBB'.
GS_DATA19-NUM = 4.
APPEND GS_DATA19 TO GT_DATA19.

SORT GT_DATA19.

*DELETE ADJACENT DUPLICATES FROM GT_DATA19
*COMPARING ALL FIELDS. "모든필드가 똑같으면 삭제"

*DELETE ADJACENT DUPLICATES FROM GT_DATA19
*COMPARING CHAR1. "CHAR1 필드가 똑같으면 삭제"

*CL_DEMO_OUTPUT=>DISPLAY( GT_DATA19 ).

READ TABLE GT_DATA19 INTO GS_DATA19 WITH KEY CHAR1 = '123'.
IF SY-SUBRC = 0.
    WRITE : / GS_DATA19-CHAR1.
ENDIF.

WRITE : / GS_DATA19-CHAR1.

DATA : BEGIN OF GS_DATA20,
                CHAR1,
                CHAR2(5),
                NUM TYPE I,
                END OF GS_DATA20.

DATA : GT_DATA20 LIKE TABLE OF GS_DATA20.

GS_DATA20-CHAR1 = 'A'.
GS_DATA20-CHAR2 = '가'.
GS_DATA20-NUM = 1.
APPEND GS_DATA20 TO GT_DATA20.

GS_DATA20-CHAR1 = 'B'.
GS_DATA20-CHAR2 = '나'.
GS_DATA20-NUM = 1.
APPEND GS_DATA20 TO GT_DATA20.

GS_DATA20-CHAR1 = 'C'.
GS_DATA20-CHAR2 = '다'.
GS_DATA20-NUM = 1.
APPEND GS_DATA20 TO GT_DATA20.

READ TABLE GT_DATA20 INTO GS_DATA20 WITH TABLE KEY CHAR1 = 'A'
                                                 CHAR2 = '가'.

IF SY-SUBRC = 0.

WRITE : / GS_DATA20-CHAR1,
          GS_DATA20-CHAR2,
          GS_DATA20-NUM.

ENDIF.
